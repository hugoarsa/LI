<!DOCTYPE html>
<html><head>
<title>clpfd.pl -- CLP(FD): Constraint Logic Programming over Finite Domains</title>

<link rel="stylesheet" type="text/css" href="clpfd_files/footer.css">
<link rel="stylesheet" type="text/css" href="clpfd_files/plweb.css">
<link rel="stylesheet" type="text/css" href="clpfd_files/swipl.css">
<script type="text/javascript" src="clpfd_files/jquery.min.js">

</script>
<link rel="stylesheet" type="text/css" href="clpfd_files/jquery-ui.min.css">
<link rel="stylesheet" type="text/css" href="clpfd_files/style_002.css">
<link rel="stylesheet" type="text/css" href="clpfd_files/style.css">
<link rel="stylesheet" type="text/css" href="clpfd_files/pldoc.css">
<script type="text/javascript" src="clpfd_files/menu.js">

</script>
<script type="text/javascript" src="clpfd_files/jquery-ui.min.js">

</script>
<script type="text/javascript" src="clpfd_files/jquery.markitup.js">

</script>
<script type="text/javascript" src="clpfd_files/pldoc.js">

</script>
<script type="text/javascript" src="clpfd_files/set.js">

</script>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link rel="shortcut icon" href="https://www.swi-prolog.org/icons/favicon.ico">
<link rel="apple-touch-icon" href="https://www.swi-prolog.org/apple-touch-icon.png">

</head>
<body>
<div class="outer-container">
<div id="upper-header">

<table id="upper-header-contents">
<tbody><tr><td id="dyknow-container">


<title>SWI-Prolog Did You Know</title>

<meta http-equiv="content-type" content="text/html; charset=UTF-8">



<span class="lbl">Did you know?</span> <span id="dyknow"><a href="https://www.swi-prolog.org/pldoc/package/semweb.html">SWI-Prolog has <b>powerful Semantic Web tools</b></a></span>


</td><td id="search-container"><span class="lbl">Search Documentation:</span>

<form action="/search" id="search-form">
<input name="for" id="for" class="ui-autocomplete-input" autocomplete="off"><input id="submit-for" type="submit" value="Search">
<script type="text/javascript">

    $(function() {
	function htmlEncode(text) {
	  if ( !text ) return "";
	  return document.createElement('a')
			 .appendChild(document.createTextNode(text))
			 .parentNode
			 .innerHTML;
	}
	$("#"+"for").autocomplete({
	minLength: 1,
	delay: 0.3,
	source: "/autocomplete/ac_predicate",
	focus: function(event,ui) {
	  $("#"+"for").val(ui.item.label);
	  return false;
	},
	select: function(event,ui) {
	  $("#"+"for").val(ui.item.label);
	  window.location.href = ui.item.href;
	  return false;
	}
	})
	.data("ui-autocomplete")._renderItem = function(ul,item) {
	var label = String(htmlEncode(item.label)).replace(
	    htmlEncode(this.term),
	    "<span class=\"acmatch\">"+this.term+"</span>");
	var tag = item.tag ? " <i>["+item.tag+"]</i>" : "";
	return $("<li>")
	  .append("<a class=\""+item.class+"\">"+label+tag+"</a>")
	  .appendTo(ul)
	};
	});

</script>
</form>

</td></tr>
</tbody></table>

</div>

<table id="header-line-area">
<tbody><tr><td id="logo"><a href="http://www.swi-prolog.org/"><img class="owl" src="clpfd_files/swipl.png" alt="SWI-Prolog owl logo" title="SWI-Prolog owl logo"></a></td><td class="primary-header">clpfd.pl -- CLP(FD): Constraint Logic Programming over Finite Domains</td></tr>
</tbody></table>

<div class="file-buttons"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?public_only=false"><img class="action" alt="Public" title="Click to include private" src="clpfd_files/public.png"></a><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src"><img class="action" alt="Show source" title="Show source" src="clpfd_files/source.png"></a></div>

<div id="menubar">
<div class="menubar fixed-width">
<ul class="menubar-container">
<li><a href="https://www.swi-prolog.org/">HOME</a></li>
<li>DOWNLOAD
<ul>
<li><a href="https://www.swi-prolog.org/Download.html">SWI-Prolog</a></li>
<li><a href="https://www.swi-prolog.org/build/">Sources/building</a></li>
<li><a href="https://www.swi-prolog.org/Docker.html">Docker images</a></li>
<li><a href="https://www.swi-prolog.org/pack/list">Add-ons</a></li>
<li><a href="https://github.com/SWI-Prolog">Browse GIT<img class="ext-link" src="clpfd_files/ext-link.png" alt="External"></a></li>
</ul>
</li>
<li>DOCUMENTATION
<ul>
<li><a href="https://www.swi-prolog.org/pldoc/refman/">Manual</a></li>
<li><a href="https://www.swi-prolog.org/pldoc/package/">Packages</a></li>
<li><a href="https://www.swi-prolog.org/FAQ/">FAQ</a></li>
<li><a href="https://www.swi-prolog.org/pldoc/man?section=cmdline">Command line</a></li>
<li><a href="https://www.swi-prolog.org/pldoc/package/pldoc.html">PlDoc</a></li>
<li>Bluffers<span class="arrow">▶</span>
<ul>
<li><a href="https://www.swi-prolog.org/pldoc/man?section=syntax">Prolog syntax</a></li>
<li><a href="https://www.swi-prolog.org/pldoc/man?section=emacsbluff">PceEmacs</a></li>
<li><a href="https://www.swi-prolog.org/pldoc/man?section=htmlwrite">HTML generation</a></li>
</ul>
</li>
<li><a href="https://www.swi-prolog.org/license.html">License</a></li>
<li><a href="https://www.swi-prolog.org/Publications.html">Publications</a></li>
<li><a href="https://www.swi-prolog.org/pldoc/man?section=extensions">Rev 7 Extensions</a></li>
</ul>
</li>
<li>TUTORIALS
<ul>
<li>Beginner<span class="arrow">▶</span>
<ul>
<li><a href="https://www.swi-prolog.org/pldoc/man?section=quickstart">Getting started</a></li>
<li><a href="http://lpn.swi-prolog.org/">Learn Prolog Now!<img class="ext-link" src="clpfd_files/ext-link.png" alt="External"></a></li>
<li><a href="http://book.simply-logical.space/">Simply Logical<img class="ext-link" src="clpfd_files/ext-link.png" alt="External"></a></li>
<li><a href="https://www.swi-prolog.org/pldoc/man?section=debugoverview">Debugger</a></li>
<li><a href="https://www.swi-prolog.org/IDE.html">Development tools</a></li>
</ul>
</li>
<li>Advanced<span class="arrow">▶</span>
<ul>
<li><a href="http://chiselapp.com/user/ttmrichter/repository/gng/doc/trunk/output/tutorials/swiplmodtut.html">Modules<img class="ext-link" src="clpfd_files/ext-link.png" alt="External"></a></li>
<li><a href="https://www.github.com/Anniepoo/swipldcgtut/blob/master/dcgcourse.adoc">Grammars (DCGs)<img class="ext-link" src="clpfd_files/ext-link.png" alt="External"></a></li>
<li><a href="https://www.github.com/Anniepoo/swiplclpfd/blob/master/clpfd.adoc">clp(fd)<img class="ext-link" src="clpfd_files/ext-link.png" alt="External"></a></li>
<li><a href="https://www.github.com/Anniepoo/swiplmessage/blob/master/message.adoc">Printing messages<img class="ext-link" src="clpfd_files/ext-link.png" alt="External"></a></li>
<li><a href="http://chiselapp.com/user/ttmrichter/repository/swipldoctut/doc/tip/doc/tutorial.html">PlDoc<img class="ext-link" src="clpfd_files/ext-link.png" alt="External"></a></li>
</ul>
</li>
<li>Web applications<span class="arrow">▶</span>
<ul>
<li><a href="https://www.github.com/Anniepoo/swiplwebtut/blob/master/web.adoc">Web applications<img class="ext-link" src="clpfd_files/ext-link.png" alt="External"></a></li>
<li><a href="https://github.com/triska/letswicrypt">Let's Encrypt!<img class="ext-link" src="clpfd_files/ext-link.png" alt="External"></a></li>
<li><a href="https://www.swi-prolog.org/pengines/">Pengines</a></li>
</ul>
</li>
<li>Semantic web<span class="arrow">▶</span>
<ul>
<li><a href="https://cliopatria.swi-prolog.org/tutorial/">ClioPatria<img class="ext-link" src="clpfd_files/ext-link.png" alt="External"></a></li>
<li><a href="https://www.swi-prolog.org/howto/UseRdfMeta.html">RDF namespaces</a></li>
</ul>
</li>
<li>Graphics<span class="arrow">▶</span>
<ul>
<li><a href="https://www.swi-prolog.org/download/xpce/doc/coursenotes/coursenotes.pdf">XPCE</a></li>
<li><a href="https://www.swi-prolog.org/Graphics.html">GUI options</a></li>
</ul>
</li>
<li>Machine learning<span class="arrow">▶</span>
<ul>
<li><a href="http://cplint.ml.unife.it/">Probabilistic Logic Programming<img class="ext-link" src="clpfd_files/ext-link.png" alt="External"></a></li>
</ul>
</li>
<li>External collections<span class="arrow">▶</span>
<ul>
<li><a href="https://www.metalevel.at/prolog">Meta level tutorials<img class="ext-link" src="clpfd_files/ext-link.png" alt="External"></a></li>
</ul>
</li>
<li>For packagers<span class="arrow">▶</span>
<ul>
<li><a href="https://www.swi-prolog.org/build/guidelines.html">Linux packages</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.swi-prolog.org/community.html">COMMUNITY</a>
<ul>
<li><a href="https://web.libera.chat/?channels=##prolog">IRC<img class="ext-link" src="clpfd_files/ext-link.png" alt="External"></a></li>
<li><a href="https://swi-prolog.discourse.group/">Forum &amp; mailing list<img class="ext-link" src="clpfd_files/ext-link.png" alt="External"></a></li>
<li><a href="https://www.swi-prolog.org/blog">Blog</a></li>
<li><a href="https://www.swi-prolog.org/news/archive">News</a></li>
<li><a href="https://www.swi-prolog.org/bug.html">Report a bug</a></li>
<li><a href="https://www.swi-prolog.org/howto/SubmitPatch.html">Submit a patch</a></li>
<li><a href="https://www.swi-prolog.org/howto/Pack.html">Submit an add-on</a></li>
<li><a href="https://github.com/SWI-Prolog/roadmap">Roadmap (on GitHub)<img class="ext-link" src="clpfd_files/ext-link.png" alt="External"></a></li>
<li><a href="https://www.swi-prolog.org/Links.html">External links</a></li>
<li><a href="https://www.swi-prolog.org/contributing.html">Contributing</a></li>
<li><a href="https://www.swi-prolog.org/Code-of-Conduct.html">Code of Conduct</a></li>
<li><a href="https://www.swi-prolog.org/Contributors.html">Contributors</a></li>
<li><a href="https://www.swi-prolog.org/loot.html">SWI-Prolog items</a></li>
</ul>
</li>
<li>USERS
<ul>
<li><a href="https://www.swi-prolog.org/web/index.html">Semantic web</a></li>
<li><a href="https://www.swi-prolog.org/students/index.html">Students</a></li>
<li><a href="https://www.swi-prolog.org/research/index.html">Researchers</a></li>
<li><a href="https://www.swi-prolog.org/commercial/index.html">Commercial users</a></li>
<li><a href="https://www.swi-prolog.org/dogfood.html">Dog food</a></li>
<li><a href="https://www.swi-prolog.org/pldoc/man?section=swiorother">Is SWIPL right for me?</a></li>
</ul>
</li>
<li>WIKI
<ul>
<li><a href="https://www.swi-prolog.org/openid/login?openid.return_to=/pldoc/doc/_SWI_/library/clp/clpfd.pl">Login</a></li>
<li><a href="https://www.swi-prolog.org/wiki/changes">View changes</a></li>
<li><a href="https://www.swi-prolog.org/wiki/sandbox">Sandbox</a></li>
<li><a href="https://www.swi-prolog.org/wiki/">Wiki help</a></li>
<li><a href="https://www.swi-prolog.org/list-tags">All tags</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="breadcrumb"></div>
<div class="inner-contents pldoc">
<div id="contents" class="contents pldoc">

<p>
<strong>Development of this library has moved to SICStus Prolog.</strong></p>

<p>
Please see <a href="https://github.com/triska/clpz"><strong>CLP(Z)</strong></a> for more
information.</p>

<h2 class="wiki" id="clpfd-intro">Introduction</h2>

<p>
This library provides CLP(FD): Constraint Logic Programming over
Finite Domains. This is an instance of the general <a href="#clp">CLP(<i>X</i>)
scheme</a>, extending logic programming with reasoning over
specialised domains. CLP(FD) lets us reason about <strong>integers</strong> in a
way that honors the relational nature of Prolog.</p>

<p>
Read <a href="https://www.metalevel.at/prolog"><strong>The Power of Prolog</strong></a> to
understand how this library is meant to be used in practice.</p>

<p>
There are two major use cases of CLP(FD) constraints:</p>

<ol>
<li><a href="#clpfd-integer-arith"><strong>declarative integer arithmetic</strong></a></li>
<li>solving <strong>combinatorial problems</strong> such as planning, scheduling
and allocation tasks.</li>
</ol>

<p>
The predicates of this library can be classified as:</p>
<ul>
<li><i>arithmetic</i> constraints like <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3D/2">#=/2</a>, <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3E/2">#&gt;/2</a> and <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%5C%3D/2">#\=/2</a> <a href="#clpfd-arithmetic"></a></li>
<li>the <i>membership</i> constraints <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=in/2">in/2</a> and <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=ins/2">ins/2</a> <a href="#clpfd-membership"></a></li>
<li>the <i>enumeration</i> predicates <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=indomain/1">indomain/1</a>, <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=label/1">label/1</a> and <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=labeling/2">labeling/2</a> <a href="#clpfd-enumeration"></a></li>
<li><i>combinatorial</i> constraints like <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=all_distinct/1">all_distinct/1</a> and <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=global_cardinality/2">global_cardinality/2</a> <a href="#clpfd-global"></a></li>
<li><i>reification</i> predicates such as <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3C%3D%3D%3E/2">#&lt;==&gt;/2</a> <a href="#clpfd-reification-predicates"></a></li>
<li><i>reflection</i> predicates such as <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=fd_dom/2">fd_dom/2</a> <a href="#clpfd-reflection-predicates"></a></li>
</ul>

<p>
In most cases, <a href="#clpfd-arith-constraints"><i>arithmetic constraints</i></a>
are the only predicates you will ever need from this library. When
reasoning over integers, simply replace low-level arithmetic
predicates like <code>(is)/2</code> and <code>(&gt;)/2</code> by the corresponding CLP(FD)
constraints like <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3D/2">#=/2</a> and <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3E/2">#&gt;/2</a> to honor and preserve declarative
properties of your programs. For satisfactory performance, arithmetic
constraints are implicitly rewritten at compilation time so that
low-level fallback predicates are automatically used whenever
possible.</p>

<p>
Almost all Prolog programs also reason about integers. Therefore, it
is highly advisable that you make CLP(FD) constraints available in all
your programs. One way to do this is to put the following directive in
your <code>&lt;config&gt;/init.pl</code> initialisation file:</p>

<pre class="code" ext="">:- use_module(library(clpfd)).</pre>

<p>
All example programs that appear in the CLP(FD) documentation assume
that you have done this.</p>

<p>
Important concepts and principles of this library are illustrated by
means of usage examples that are available in a public git repository:
<a href="https://github.com/triska/clpfd"><strong>github.com/triska/clpfd</strong></a></p>

<p>
If you are used to the complicated operational considerations that
low-level arithmetic primitives necessitate, then moving to CLP(FD)
constraints may, due to their power and convenience, at first feel to
you excessive and almost like cheating. It <i>isn't</i>. Constraints are an
integral part of all popular Prolog systems, and they are designed
to help you eliminate and avoid the use of low-level and less general
primitives by providing declarative alternatives that are meant to be
used instead.</p>

<p>
When teaching Prolog, CLP(FD) constraints should be introduced
<i>before</i> explaining low-level arithmetic predicates and their
procedural idiosyncrasies. This is because constraints are easy to
explain, understand and use due to their purely relational nature. In
contrast, the modedness and directionality of low-level arithmetic
primitives are impure limitations that are better deferred to more
advanced lectures.</p>

<p>
We recommend the following reference (PDF:
<a href="https://www.metalevel.at/swiclpfd.pdf">metalevel.at/swiclpfd.pdf</a>) for
citing this library in scientific publications:</p>

<pre class="code" ext="">@inproceedings{Triska12,
  author    = {Markus Triska},
  title     = {The Finite Domain Constraint Solver of {SWI-Prolog}},
  booktitle = {FLOPS},
  series    = {LNCS},
  volume    = {7294},
  year      = {2012},
  pages     = {307-316}
}</pre>

<p>
More information about CLP(FD) constraints and their implementation is
contained in: <a href="https://www.metalevel.at/drt.pdf"><strong>metalevel.at/drt.pdf</strong></a></p>

<p>
The best way to discuss applying, improving and extending CLP(FD)
constraints is to use the dedicated <code>clpfd</code> tag on
<a href="http://stackoverflow.com/">stackoverflow.com</a>. Several of the world's
foremost CLP(FD) experts regularly participate in these discussions
and will help you for free on this platform.</p>

<h2 class="wiki" id="clpfd-arith-constraints">Arithmetic constraints</h2>

<p>
In modern Prolog systems, <b>arithmetic constraints</b> subsume and
supersede low-level predicates over integers. The main advantage of
arithmetic constraints is that they are true <i>relations</i> and can be
used in all directions. For most programs, arithmetic constraints are
the only predicates you will ever need from this library.</p>

<p>
The most important arithmetic constraint is <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3D/2">#=/2</a>, which subsumes both
<code>(is)/2</code> and <code>(=:=)/2</code> over integers. Use <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3D/2">#=/2</a> to make your programs
more general. See <a href="#clpfd-integer-arith">declarative integer
arithmetic</a>.</p>

<p>
In total, the arithmetic constraints are:</p>

<table class="wiki">
<tbody><tr><td>Expr1 <code>#=</code> Expr2</td><td>Expr1 equals Expr2</td></tr>
<tr><td>Expr1 <code>#\=</code> Expr2</td><td>Expr1 is not equal to Expr2</td></tr>
<tr><td>Expr1 <code>#&gt;=</code> Expr2</td><td>Expr1 is greater than or equal to Expr2</td></tr>
<tr><td>Expr1 <code>#=&lt;</code> Expr2</td><td>Expr1 is less than or equal to Expr2</td></tr>
<tr><td>Expr1 <code>#&gt;</code> Expr2</td><td>Expr1 is greater than Expr2</td></tr>
<tr><td>Expr1 <code>#&lt;</code> Expr2</td><td>Expr1 is less than Expr2</td></tr>
</tbody></table>

<p>
<var>Expr1</var> and <var>Expr2</var> denote <b>arithmetic expressions</b>, which are:</p>

<table class="wiki">
<tbody><tr><td><i>integer</i></td><td>Given value</td></tr>
<tr><td><i>variable</i></td><td>Unknown integer</td></tr>
<tr><td>?(<i>variable</i>)</td><td>Unknown integer</td></tr>
<tr><td>-Expr</td><td>Unary minus</td></tr>
<tr><td>Expr + Expr</td><td>Addition</td></tr>
<tr><td>Expr * Expr</td><td>Multiplication</td></tr>
<tr><td>Expr - Expr</td><td>Subtraction</td></tr>
<tr><td>Expr ^ Expr</td><td>Exponentiation</td></tr>
<tr><td><code>min(Expr,Expr)</code></td><td>Minimum of two expressions</td></tr>
<tr><td><code>max(Expr,Expr)</code></td><td>Maximum of two expressions</td></tr>
<tr><td>Expr <code>mod</code> Expr</td><td>Modulo induced by floored division</td></tr>
<tr><td>Expr <code>rem</code> Expr</td><td>Modulo induced by truncated division</td></tr>
<tr><td><code>abs(Expr)</code></td><td>Absolute value</td></tr>
<tr><td>Expr // Expr</td><td>Truncated integer division</td></tr>
<tr><td>Expr div Expr</td><td>Floored integer division</td></tr>
</tbody></table>

<p>
where <var>Expr</var> again denotes an arithmetic expression.</p>

<p>
The bitwise operations <code>(\)/1</code>, <code>(/\)/2</code>, <code>(\/)/2</code>, <code>(&gt;&gt;)/2</code>,
<code>(&lt;&lt;)/2</code>, <span class="undef">lsb/1</span>, <span class="undef">msb/1</span>, <span class="undef">popcount/1</span> and <code>(xor)/2</code> are also
supported.</p>

<h2 class="wiki" id="clpfd-integer-arith">Declarative integer arithmetic</h2>

<p>
The <a href="#clpfd-arith-constraints"><i>arithmetic constraints</i></a> <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3D/2">#=/2</a>, <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3E/2">#&gt;/2</a>
etc. are meant to be used <i>instead</i> of the primitives <code>(is)/2</code>,
<code>(=:=)/2</code>, <code>(&gt;)/2</code> etc. over integers. Almost all Prolog programs also
reason about integers. Therefore, it is recommended that you put the
following directive in your <code>&lt;config&gt;/init.pl</code> initialisation file to
make CLP(FD) constraints available in all your programs:</p>

<pre class="code" ext="">:- use_module(library(clpfd)).</pre>

<p>
Throughout the following, it is assumed that you have done this.</p>

<p>
The most basic use of CLP(FD) constraints is <i>evaluation</i> of
arithmetic expressions involving integers. For example:</p>

<pre class="code" ext="">?- X #= 1+2.
X = 3.</pre>

<p>
This could in principle also be achieved with the lower-level
predicate <code>(is)/2</code>. However, an important advantage of arithmetic
constraints is their purely relational nature: Constraints can be used
in <i>all directions</i>, also if one or more of their arguments are only
partially instantiated. For example:</p>

<pre class="code" ext="">?- 3 #= Y+2.
Y = 1.</pre>

<p>
This relational nature makes CLP(FD) constraints easy to explain and
use, and well suited for beginners and experienced Prolog programmers
alike. In contrast, when using low-level integer arithmetic, we get:</p>

<pre class="code" ext="">?- 3 is Y+2.
ERROR: is/2: Arguments are not sufficiently instantiated

?- 3 =:= Y+2.
ERROR: =:=/2: Arguments are not sufficiently instantiated</pre>

<p>
Due to the necessary operational considerations, the use of these
low-level arithmetic predicates is considerably harder to understand
and should therefore be deferred to more advanced lectures.</p>

<p>
For supported expressions, CLP(FD) constraints are drop-in
replacements of these low-level arithmetic predicates, often yielding
more general programs. See <a href="#clpfd-factorial"><span class="undef">n_factorial/2</span></a> for an
example.</p>

<p>
This library uses <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=goal_expansion/2">goal_expansion/2</a> to automatically rewrite
constraints at compilation time so that low-level arithmetic
predicates are <i>automatically</i> used whenever possible. For example,
the predicate:</p>

<pre class="code" ext="">positive_integer(N) :- N #&gt;= 1.</pre>

<p>
is executed as if it were written as:</p>

<pre class="code" ext="">positive_integer(N) :-
        (   integer(N)
        -&gt;  N &gt;= 1
        ;   N #&gt;= 1
        ).</pre>

<p>
This illustrates why the performance of CLP(FD) constraints is almost
always completely satisfactory when they are used in modes that can be
handled by low-level arithmetic. To disable the automatic rewriting,
set the Prolog flag <code>clpfd_goal_expansion</code> to <code>false</code>.</p>

<p>
If you are used to the complicated operational considerations that
low-level arithmetic primitives necessitate, then moving to CLP(FD)
constraints may, due to their power and convenience, at first feel to
you excessive and almost like cheating. It <i>isn't</i>. Constraints are an
integral part of all popular Prolog systems, and they are designed
to help you eliminate and avoid the use of low-level and less general
primitives by providing declarative alternatives that are meant to be
used instead.</p>

<h2 class="wiki" id="clpfd-factorial">Example: Factorial relation</h2>

<p>
We illustrate the benefit of using <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3D/2">#=/2</a> for more generality with a
simple example.</p>

<p>
Consider first a rather conventional definition of <span class="undef">n_factorial/2</span>,
relating each natural number <i>N</i> to its factorial <i>F</i>:</p>

<pre class="code" ext="">n_factorial(0, 1).
n_factorial(N, F) :-
        N #&gt; 0,
        N1 #= N - 1,
        n_factorial(N1, F1),
        F #= N * F1.</pre>

<p>
This program uses CLP(FD) constraints <i>instead</i> of low-level
arithmetic throughout, and everything that <i>would have worked</i> with
low-level arithmetic <i>also</i> works with CLP(FD) constraints, retaining
roughly the same performance. For example:</p>

<pre class="code" ext="">?- n_factorial(47, F).
F = 258623241511168180642964355153611979969197632389120000000000 ;
false.</pre>

<p>
Now the point: Due to the increased flexibility and generality of
CLP(FD) constraints, we are free to <i>reorder</i> the goals as follows:</p>

<pre class="code" ext="">n_factorial(0, 1).
n_factorial(N, F) :-
        N #&gt; 0,
        N1 #= N - 1,
        F #= N * F1,
        n_factorial(N1, F1).</pre>

<p>
In this concrete case, <i>termination</i> properties of the predicate are
improved. For example, the following queries now both terminate:</p>

<pre class="code" ext="">?- n_factorial(N, 1).
N = 0 ;
N = 1 ;
false.

?- n_factorial(N, 3).
false.</pre>

<p>
To make the predicate terminate if <i>any</i> argument is instantiated, add
the (implied) constraint `F #\= 0` before the recursive call.
Otherwise, the query <code>n_factorial(N, 0)</code> is the only non-terminating
case of this kind.</p>

<p>
The value of CLP(FD) constraints does <i>not</i> lie in completely freeing
us from <i>all</i> procedural phenomena. For example, the two programs do
not even have the same <i>termination properties</i> in all cases.
Instead, the primary benefit of CLP(FD) constraints is that they allow
you to try different execution orders and apply <a href="https://www.metalevel.at/prolog/debugging"><strong>declarative
debugging</strong></a>
techniques <i>at all</i>! Reordering goals (and clauses) can significantly
impact the performance of Prolog programs, and you are free to try
different variants if you use declarative approaches. Moreover, since
all CLP(FD) constraints <i>always terminate</i>, placing them earlier can
at most <i>improve</i>, never worsen, the termination properties of your
programs. An additional benefit of CLP(FD) constraints is that they
eliminate the complexity of introducing <code>(is)/2</code> and <code>(=:=)/2</code> to
beginners, since <i>both</i> predicates are subsumed by <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3D/2">#=/2</a> when reasoning
over integers.</p>

<p>
In the case above, the clauses are mutually exclusive <i>if</i> the first
argument is sufficiently instantiated. To make the predicate
deterministic in such cases while retaining its generality, you can
use <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=zcompare/3">zcompare/3</a> to <i>reify</i> a comparison, making the different cases
distinguishable by pattern matching. For example, in this concrete
case and others like it, you can use <code>zcompare(Comp, 0, N)</code> to obtain as
<var>Comp</var> the symbolic outcome (<code>&lt;</code>, <code>=</code>, <code>&gt;</code>) of 0 compared to N.</p>

<h2 class="wiki" id="clpfd-combinatorial">Combinatorial constraints</h2>

<p>
In addition to subsuming and replacing low-level arithmetic
predicates, CLP(FD) constraints are often used to solve combinatorial
problems such as planning, scheduling and allocation tasks. Among the
most frequently used <b>combinatorial constraints</b> are <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=all_distinct/1">all_distinct/1</a>,
<a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=global_cardinality/2">global_cardinality/2</a> and <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=cumulative/2">cumulative/2</a>. This library also provides
several other constraints like <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=disjoint2/1">disjoint2/1</a> and <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=automaton/8">automaton/8</a>, which are
useful in more specialized applications.</p>

<h2 class="wiki" id="clpfd-domains">Domains</h2>

<p>
Each CLP(FD) variable has an associated set of admissible integers,
which we call the variable's <b>domain</b>. Initially, the domain of each
CLP(FD) variable is the set of <i>all</i> integers. CLP(FD) constraints
like <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3D/2">#=/2</a>, <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3E/2">#&gt;/2</a> and <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%5C%3D/2">#\=/2</a> can at most reduce, and never extend, the
domains of their arguments. The constraints <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=in/2">in/2</a> and <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=ins/2">ins/2</a> let us
explicitly state domains of CLP(FD) variables. The process of
determining and adjusting domains of variables is called constraint
<b>propagation</b>, and it is performed automatically by this library. When
the domain of a variable contains only one element, then the variable
is automatically unified to that element.</p>

<p>
Domains are taken into account when further constraints are stated,
and by enumeration predicates like <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=labeling/2">labeling/2</a>.</p>

<h2 class="wiki" id="clpfd-sudoku">Example: Sudoku</h2>

<p>
As another example, consider <i>Sudoku</i>: It is a popular puzzle
over integers that can be easily solved with CLP(FD) constraints.</p>

<pre class="code" ext="">sudoku(Rows) :-
        length(Rows, 9), maplist(same_length(Rows), Rows),
        append(Rows, Vs), Vs ins 1..9,
        maplist(all_distinct, Rows),
        transpose(Rows, Columns),
        maplist(all_distinct, Columns),
        Rows = [As,Bs,Cs,Ds,Es,Fs,Gs,Hs,Is],
        blocks(As, Bs, Cs),
        blocks(Ds, Es, Fs),
        blocks(Gs, Hs, Is).

blocks([], [], []).
blocks([N1,N2,N3|Ns1], [N4,N5,N6|Ns2], [N7,N8,N9|Ns3]) :-
        all_distinct([N1,N2,N3,N4,N5,N6,N7,N8,N9]),
        blocks(Ns1, Ns2, Ns3).

problem(1, [[_,_,_,_,_,_,_,_,_],
            [_,_,_,_,_,3,_,8,5],
            [_,_,1,_,2,_,_,_,_],
            [_,_,_,5,_,7,_,_,_],
            [_,_,4,_,_,_,1,_,_],
            [_,9,_,_,_,_,_,_,_],
            [5,_,_,_,_,_,_,7,3],
            [_,_,2,_,1,_,_,_,_],
            [_,_,_,_,4,_,_,_,9]]).</pre>

<p>
Sample query:</p>

<pre class="code" ext="">?- problem(1, Rows), sudoku(Rows), maplist(writeln, Rows).
[9,8,7,6,5,4,3,2,1]
[2,4,6,1,7,3,9,8,5]
[3,5,1,9,2,8,7,4,6]
[1,2,8,5,3,7,6,9,4]
[6,3,4,8,9,2,1,5,7]
[7,9,5,4,6,1,8,3,2]
[5,1,9,2,8,6,4,7,3]
[4,7,2,3,1,9,5,6,8]
[8,6,3,7,4,5,2,1,9]
Rows = [[9, 8, 7, 6, 5, 4, 3, 2|...], ... , [...|...]].</pre>

<p>
In this concrete case, the constraint solver is strong enough to find
the unique solution without any search. For the general case, see
<a href="#clpfd-search">search</a>.</p>

<h2 class="wiki" id="clpfd-residual-goals">Residual goals</h2>

<p>
Here is an example session with a few queries and their answers:</p>

<pre class="code" ext="">?- X #&gt; 3.
X in 4..sup.

?- X #\= 20.
X in inf..19\/21..sup.

?- 2*X #= 10.
X = 5.

?- X*X #= 144.
X in -12\/12.

?- 4*X + 2*Y #= 24, X + Y #= 9, [X,Y] ins 0..sup.
X = 3,
Y = 6.

?- X #= Y #&lt;==&gt; B, X in 0..3, Y in 4..5.
B = 0,
X in 0..3,
Y in 4..5.</pre>

<p>
The answers emitted by the toplevel are called <i>residual programs</i>,
and the goals that comprise each answer are called <strong>residual goals</strong>.
In each case above, and as for all pure programs, the residual program
is declaratively equivalent to the original query. From the residual
goals, it is clear that the constraint solver has deduced additional
domain restrictions in many cases.</p>

<p>
To inspect residual goals, it is best to let the toplevel display them
for us. Wrap the call of your predicate into <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=call_residue_vars/2">call_residue_vars/2</a> to
make sure that all constrained variables are displayed. To make the
constraints a variable is involved in available as a Prolog term for
further reasoning within your program, use <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=copy_term/3">copy_term/3</a>. For example:</p>

<pre class="code" ext="">?- X #= Y + Z, X in 0..5, copy_term([X,Y,Z], [X,Y,Z], Gs).
Gs = [clpfd: (X in 0..5), clpfd: (Y+Z#=X)],
X in 0..5,
Y+Z#=X.</pre>

<p>
This library also provides <i>reflection</i> predicates (like <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=fd_dom/2">fd_dom/2</a>,
<a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=fd_size/2">fd_size/2</a> etc.) with which we can inspect a variable's current
domain. These predicates can be useful if you want to implement your
own labeling strategies.</p>

<h2 class="wiki" id="clpfd-search">Core relations and search</h2>

<p>
Using CLP(FD) constraints to solve combinatorial tasks typically
consists of two phases:</p>

<ol>
<li><strong>Modeling</strong>. In this phase, all relevant constraints are stated.</li>
<li><strong>Search</strong>. In this phase, <i>enumeration predicates</i> are used
to search for concrete solutions.</li>
</ol>

<p>
It is good practice to keep the modeling part, via a dedicated
predicate called the <b>core relation</b>, separate from the actual
search for solutions. This lets us observe termination and
determinism properties of the core relation in isolation from the
search, and more easily try different search strategies.</p>

<p>
As an example of a constraint satisfaction problem, consider the
cryptoarithmetic puzzle SEND + MORE = MONEY, where different letters
denote distinct integers between 0 and 9. It can be modeled in CLP(FD)
as follows:</p>

<pre class="code" ext="">puzzle([S,E,N,D] + [M,O,R,E] = [M,O,N,E,Y]) :-
        Vars = [S,E,N,D,M,O,R,Y],
        Vars ins 0..9,
        all_different(Vars),
                  S*1000 + E*100 + N*10 + D +
                  M*1000 + O*100 + R*10 + E #=
        M*10000 + O*1000 + N*100 + E*10 + Y,
        M #\= 0, S #\= 0.</pre>

<p>
Notice that we are <i>not</i> using <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=labeling/2">labeling/2</a> in this predicate, so that
we can first execute and observe the modeling part in isolation.
Sample query and its result (actual variables replaced for
readability):</p>

<pre class="code" ext="">?- puzzle(As+Bs=Cs).
As = [9, A2, A3, A4],
Bs = [1, 0, B3, A2],
Cs = [1, 0, A3, A2, C5],
A2 in 4..7,
all_different([9, A2, A3, A4, 1, 0, B3, C5]),
91*A2+A4+10*B3#=90*A3+C5,
A3 in 5..8,
A4 in 2..8,
B3 in 2..8,
C5 in 2..8.</pre>

<p>
From this answer, we see that this core relation <i>terminates</i> and is in
fact <i>deterministic</i>. Moreover, we see from the residual goals that
the constraint solver has deduced more stringent bounds for all
variables. Such observations are only possible if modeling and search
parts are cleanly separated.</p>

<p>
Labeling can then be used to search for solutions in a separate
predicate or goal:</p>

<pre class="code" ext="">?- puzzle(As+Bs=Cs), label(As).
As = [9, 5, 6, 7],
Bs = [1, 0, 8, 5],
Cs = [1, 0, 6, 5, 2] ;
false.</pre>

<p>
In this case, it suffices to label a subset of variables to find the
puzzle's unique solution, since the constraint solver is strong enough
to reduce the domains of remaining variables to singleton sets. In
general though, it is necessary to label all variables to obtain
ground solutions.</p>

<h2 class="wiki" id="clpfd-n-queens">Example: Eight queens puzzle</h2>

<p>
We illustrate the concepts of the preceding sections by means of the
so-called <i>eight queens puzzle</i>. The task is to place 8 queens on an
8x8 chessboard such that none of the queens is under attack. This
means that no two queens share the same row, column or diagonal.</p>

<p>
To express this puzzle via CLP(FD) constraints, we must first pick a
suitable representation. Since CLP(FD) constraints reason over
<i>integers</i>, we must find a way to map the positions of queens to
integers. Several such mappings are conceivable, and it is not
immediately obvious which we should use. On top of that, different
constraints can be used to express the desired relations. For such
reasons, <i>modeling</i> combinatorial problems via CLP(FD) constraints
often necessitates some creativity and has been described as more of
an art than a science.</p>

<p>
In our concrete case, we observe that there must be exactly one queen
per column. The following representation therefore suggests itself: We
are looking for 8 integers, one for each column, where each integer
denotes the <i>row</i> of the queen that is placed in the respective
column, and which are subject to certain constraints.</p>

<p>
In fact, let us now generalize the task to the so-called <i>N queens
puzzle</i>, which is obtained by replacing 8 by <i>N</i> everywhere it occurs
in the above description. We implement the above considerations in the
<strong>core relation</strong> <a href="https://www.swi-prolog.org/scratch/swipl/src/plweb/pack/mirror/fd/ad/fdad63f18ec52ae96691f18fbbd5c912117e6871/prolog/zdd/zdd-samples.pl#n_queens/2">n_queens/2</a>, where the first argument is the number
of queens (which is identical to the number of rows and columns of the
generalized chessboard), and the second argument is a list of <i>N</i>
integers that represents a solution in the form described above.</p>

<pre class="code" ext="">n_queens(N, Qs) :-
        length(Qs, N),
        Qs ins 1..N,
        safe_queens(Qs).

safe_queens([]).
safe_queens([Q|Qs]) :- safe_queens(Qs, Q, 1), safe_queens(Qs).

safe_queens([], _, _).
safe_queens([Q|Qs], Q0, D0) :-
        Q0 #\= Q,
        abs(Q0 - Q) #\= D0,
        D1 #= D0 + 1,
        safe_queens(Qs, Q0, D1).</pre>

<p>
Note that all these predicates can be used in <i>all directions</i>: We
can use them to <i>find</i> solutions, <i>test</i> solutions and <i>complete</i>
partially instantiated solutions.</p>

<p>
The original task can be readily solved with the following query:</p>

<pre class="code" ext="">?- n_queens(8, Qs), label(Qs).
Qs = [1, 5, 8, 6, 3, 7, 2, 4] .</pre>

<p>
Using suitable labeling strategies, we can easily find solutions with
80 queens and more:</p>

<pre class="code" ext="">?- n_queens(80, Qs), labeling([ff], Qs).
Qs = [1, 3, 5, 44, 42, 4, 50, 7, 68|...] .

?- time((n_queens(90, Qs), labeling([ff], Qs))).
% 5,904,401 inferences, 0.722 CPU in 0.737 seconds (98% CPU)
Qs = [1, 3, 5, 50, 42, 4, 49, 7, 59|...] .</pre>

<p>
Experimenting with different search strategies is easy because we have
separated the core relation from the actual search.</p>

<h2 class="wiki" id="clpfd-optimisation">Optimisation</h2>

<p>
We can use <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=labeling/2">labeling/2</a> to minimize or maximize the value of a CLP(FD)
expression, and generate solutions in increasing or decreasing order
of the value. See the labeling options <code>min(Expr)</code> and <code>max(Expr)</code>,
respectively.</p>

<p>
Again, to easily try different labeling options in connection with
optimisation, we recommend to introduce a dedicated predicate for
posting constraints, and to use <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=labeling/2">labeling/2</a> in a separate goal. This
way, we can observe properties of the core relation in isolation,
and try different labeling options without recompiling our code.</p>

<p>
If necessary, we can use <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=once/1">once/1</a> to commit to the first optimal
solution. However, it is often very valuable to see alternative
solutions that are <i>also</i> optimal, so that we can choose among optimal
solutions by other criteria. For the sake of
<a href="https://www.metalevel.at/prolog/purity"><strong>purity</strong></a> and
completeness, we recommend to avoid <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=once/1">once/1</a> and other constructs that
lead to impurities in CLP(FD) programs.</p>

<p>
Related to optimisation with CLP(FD) constraints are
<a href="http://eu.swi-prolog.org/man/simplex.html"><code>library(simplex)</code></a> and
CLP(Q) which reason about <i>linear</i> constraints over rational numbers.</p>

<h2 class="wiki" id="clpfd-reification">Reification</h2>

<p>
The constraints <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=in/2">in/2</a>, <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=in_set/2">in_set/2</a>, <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3D/2">#=/2</a>, <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%5C%3D/2">#\=/2</a>, <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3C/2">#&lt;/2</a>, <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3E/2">#&gt;/2</a>, <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3D%3C/2">#=&lt;/2</a>, and
<a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3E%3D/2">#&gt;=/2</a> can be <i>reified</i>, which means reflecting their truth values into
Boolean values represented by the integers 0 and 1. Let P and Q denote
reifiable constraints or Boolean variables, then:</p>

<table class="wiki">
<tbody><tr><td>#\ Q</td><td>True iff Q is false</td></tr>
<tr><td>P #\/ Q</td><td>True iff either P or Q</td></tr>
<tr><td>P #/\ Q</td><td>True iff both P and Q</td></tr>
<tr><td>P #\ Q</td><td>True iff either P or Q, but not both</td></tr>
<tr><td>P #&lt;==&gt; Q</td><td>True iff P and Q are equivalent</td></tr>
<tr><td>P #==&gt; Q</td><td>True iff P implies Q</td></tr>
<tr><td>P #&lt;== Q</td><td>True iff Q implies P</td></tr>
</tbody></table>

<p>
The constraints of this table are reifiable as well.</p>

<p>
When reasoning over Boolean variables, also consider using
CLP(B) constraints as provided by
<a href="http://eu.swi-prolog.org/man/clpb.html"><code>library(clpb)</code></a>.</p>

<h2 class="wiki" id="clpfd-monotonicity">Enabling monotonic CLP(FD)</h2>

<p>
In the default execution mode, CLP(FD) constraints still exhibit some
non-relational properties. For example, <i>adding</i> constraints can yield
new solutions:</p>

<pre class="code" ext="">?-          X #= 2, X = 1+1.
false.

?- X = 1+1, X #= 2, X = 1+1.
X = 1+1.</pre>

<p>
This behaviour is highly problematic from a logical point of view, and
it may render declarative debugging techniques inapplicable.</p>

<p>
Set the Prolog flag <code>clpfd_monotonic</code> to <code>true</code> to make CLP(FD)
<strong>monotonic</strong>: This means that <i>adding</i> new constraints <i>cannot</i> yield
new solutions. When this flag is <code>true</code>, we must wrap variables that
occur in arithmetic expressions with the functor <code>(?)/1</code> or <code>(#)/1</code>. For
example:</p>

<pre class="code" ext="">?- set_prolog_flag(clpfd_monotonic, true).
true.

?- #(X) #= #(Y) + #(Z).
#(Y)+ #(Z)#= #(X).

?-          X #= 2, X = 1+1.
ERROR: Arguments are not sufficiently instantiated</pre>

<p>
The wrapper can be omitted for variables that are already constrained
to integers.</p>

<h2 class="wiki" id="clpfd-custom-constraints">Custom constraints</h2>

<p>
We can define custom constraints. The mechanism to do this is not yet
finalised, and we welcome suggestions and descriptions of use cases
that are important to you.</p>

<p>
As an example of how it can be done currently, let us define a new
custom constraint <code>oneground(X,Y,Z)</code>, where Z shall be 1 if at least
one of X and Y is instantiated:</p>

<pre class="code" ext="">:- multifile clpfd:run_propagator/2.

oneground(X, Y, Z) :-
        clpfd:make_propagator(oneground(X, Y, Z), Prop),
        clpfd:init_propagator(X, Prop),
        clpfd:init_propagator(Y, Prop),
        clpfd:trigger_once(Prop).

clpfd:run_propagator(oneground(X, Y, Z), MState) :-
        (   integer(X) -&gt; clpfd:kill(MState), Z = 1
        ;   integer(Y) -&gt; clpfd:kill(MState), Z = 1
        ;   true
        ).</pre>

<p>
First, <a href="#make_propagator/2">make_propagator/2</a> is used to transform a user-defined
representation of the new constraint to an internal form. With
<a href="#init_propagator/2">init_propagator/2</a>, this internal form is then attached to X and
Y. From now on, the propagator will be invoked whenever the domains of
X or Y are changed. Then, <a href="#trigger_once/1">trigger_once/1</a> is used to give the
propagator its first chance for propagation even though the variables'
domains have not yet changed. Finally, <a href="#run_propagator/2">run_propagator/2</a> is
extended to define the actual propagator. As explained, this predicate
is automatically called by the constraint solver. The first argument
is the user-defined representation of the constraint as used in
<a href="#make_propagator/2">make_propagator/2</a>, and the second argument is a mutable state
that can be used to prevent further invocations of the propagator when
the constraint has become entailed, by using <a href="#kill/1">kill/1</a>. An example
of using the new constraint:</p>

<pre class="code" ext="">?- oneground(X, Y, Z), Y = 5.
Y = 5,
Z = 1,
X in inf..sup.</pre>

<h2 class="wiki" id="clpfd-applications">Applications</h2>

<p>
CLP(FD) applications that we find particularly impressive and worth
studying include:</p>
<ul>
<li>Michael Hendricks uses CLP(FD) constraints for flexible reasoning
about <i>dates</i> and <i>times</i> in the
<a href="http://www.swi-prolog.org/pack/list?p=julian"><code>julian</code></a> package.</li>
<li>Julien Cumin uses CLP(FD) constraints for integer arithmetic in
<a href="https://github.com/JCumin/Brachylog"><code>Brachylog</code></a>.</li>
</ul>

<h2 class="wiki" id="clpfd-acknowledgments">Acknowledgments</h2>

<p>
This library gives you a glimpse of what <a href="https://sicstus.sics.se/"><strong>SICStus
Prolog</strong></a> can do. The API is intentionally
mostly compatible with that of SICStus Prolog, so that you can easily
switch to a much more feature-rich and much faster CLP(FD) system when
you need it. I thank <a href="https://www.sics.se/~matsc/">Mats Carlsson</a>, the
designer and main implementor of SICStus Prolog, for his elegant
example. I first encountered his system as part of the excellent
<a href="http://www.complang.tuwien.ac.at/ulrich/gupu/"><strong>GUPU</strong></a> teaching
environment by <a href="http://www.complang.tuwien.ac.at/ulrich/">Ulrich
Neumerkel</a>. Ulrich was also
the first and most determined tester of the present system, filing
hundreds of comments and suggestions for improvement. <a href="https://people.cs.kuleuven.be/~tom.schrijvers/">Tom
Schrijvers</a> has
contributed several constraint libraries to SWI-Prolog, and I learned
a lot from his coding style and implementation examples. <a href="https://people.cs.kuleuven.be/~bart.demoen/">Bart
Demoen</a> was a driving
force behind the implementation of attributed variables in SWI-Prolog,
and this library could not even have started without his prior work
and contributions. Thank you all!</p>

<h2 class="wiki" id="clpfd-predicate-index">CLP(FD) predicate index</h2>

<p>
In the following, each CLP(FD) predicate is described in more detail.</p>

<p>
We recommend the following link to refer to this manual:</p>

<p>
<a href="http://eu.swi-prolog.org/man/clpfd.html">http://eu.swi-prolog.org/man/clpfd.html</a></p>

<dl class="tags">
<dt class="keyword-author">author</dt><dd class="keyword-author">- <a href="https://www.metalevel.at/">Markus Triska</a></dd>
</dl>

<dl>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#in/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="in/2"><b class="pred">in</b><var class="arglist">(?Var, +Domain)</var></a></dt><dd class="defbody"><var>Var</var> is an element of <var>Domain</var>. <var>Domain</var> is one of:

<dl class="termlist">
<dt class="term"><span class="pl-avar">Integer</span></dt><dd>Singleton set consisting only of <i><var>Integer</var></i>.</dd>
<dt class="term"><b class="pred">..</b><var class="arglist">(Lower, Upper)</var></dt><dd>All integers <i>I</i> such that <i><var>Lower</var></i> =&lt; <i>I</i> =&lt; <i><var>Upper</var></i>.
<i><var>Lower</var></i> must be an integer or the atom <b>inf</b>, which
denotes negative infinity. <i><var>Upper</var></i> must be an integer or
the atom <b>sup</b>, which denotes positive infinity.</dd>
<dt class="term"><var class="arglist">Domain1</var> <b class="pred">\/</b> <var class="arglist">Domain2</var></dt><dd>The union of <var>Domain1</var> and <var>Domain2</var>.</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#ins/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="ins/2"><b class="pred">ins</b><var class="arglist">(+Vars, +Domain)</var></a></dt><dd class="defbody">The variables in the list <var>Vars</var> are elements of <var>Domain</var>. See <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=in/2">in/2</a> for
the syntax of <var>Domain</var>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#indomain/1"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="indomain/1"><b class="pred">indomain</b><var class="arglist">(?Var)</var></a></dt><dd class="defbody">Bind <var>Var</var> to all feasible values of its domain on backtracking. The
domain of <var>Var</var> must be finite.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#label/1"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="label/1"><b class="pred">label</b><var class="arglist">(+Vars)</var></a></dt><dd class="defbody">Equivalent to <code>labeling([], Vars)</code>. See <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=labeling/2">labeling/2</a>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#labeling/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="labeling/2"><b class="pred">labeling</b><var class="arglist">(+Options, +Vars)</var></a></dt><dd class="defbody">Assign a value to each variable in <var>Vars</var>. Labeling means systematically
trying out values for the finite domain variables <var>Vars</var> until all of
them are ground. The domain of each variable in <var>Vars</var> must be finite.
<var>Options</var> is a list of options that let you exhibit some control over
the search process. Several categories of options exist:

<p>
The variable selection strategy lets you specify which variable of
<var>Vars</var> is labeled next and is one of:</p>

<dl class="termlist">
<dt class="term"><span class="functor">leftmost</span></dt><dd>Label the variables in the order they occur in <var>Vars</var>. This is the
default.</dd>
<dt class="term"><span class="functor">ff</span></dt><dd><i>First fail</i>. Label the leftmost variable with smallest domain next,
in order to detect infeasibility early. This is often a good
strategy.</dd>
<dt class="term"><span class="functor">ffc</span></dt><dd>Of the variables with smallest domains, the leftmost one
participating in most constraints is labeled next.</dd>
<dt class="term"><span class="functor">min</span></dt><dd>Label the leftmost variable whose lower bound is the lowest next.</dd>
<dt class="term"><span class="functor">max</span></dt><dd>Label the leftmost variable whose upper bound is the highest next.</dd>
</dl>

<p>
The value order is one of:</p>

<dl class="termlist">
<dt class="term"><span class="functor">up</span></dt><dd>Try the elements of the chosen variable's domain in ascending order.
This is the default.</dd>
<dt class="term"><span class="functor">down</span></dt><dd>Try the domain elements in descending order.</dd>
</dl>

<p>
The branching strategy is one of:</p>

<dl class="termlist">
<dt class="term"><span class="functor">step</span></dt><dd>For each variable X, a choice is made between X = V and X #\= V,
where V is determined by the value ordering options. This is the
default.</dd>
<dt class="term"><span class="functor">enum</span></dt><dd>For each variable X, a choice is made between X = V_1, X = V_2
etc., for all values V_i of the domain of X. The order is
determined by the value ordering options.</dd>
<dt class="term"><span class="functor">bisect</span></dt><dd>For each variable X, a choice is made between X #=&lt; M and X #&gt; M,
where M is the midpoint of the domain of X.</dd>
</dl>

<p>
At most one option of each category can be specified, and an option
must not occur repeatedly.</p>

<p>
The order of solutions can be influenced with:</p>
<ul>
<li><code>min(Expr)</code></li>
<li><code>max(Expr)</code></li>
</ul>

<p>
This generates solutions in ascending/descending order with respect
to the evaluation of the arithmetic expression Expr. Labeling <var>Vars</var>
must make Expr ground. If several such options are specified, they
are interpreted from left to right, e.g.:</p>

<pre class="code" ext="">?- [X,Y] ins 10..20, labeling([max(X),min(Y)],[X,Y]).</pre>

<p>
This generates solutions in descending order of X, and for each
binding of X, solutions are generated in ascending order of Y. To
obtain the incomplete behaviour that other systems exhibit with
"<code>maximize(Expr)</code>" and "<code>minimize(Expr)</code>", use <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=once/1">once/1</a>, e.g.:</p>

<pre class="code" ext="">once(labeling([max(Expr)], Vars))</pre>

<p>
Labeling is always complete, always terminates, and yields no
redundant solutions. See <a href="#clpfd-search">core relations and
search</a> for usage advice.</p></dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#all_different/1"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="all_different/1"><b class="pred">all_different</b><var class="arglist">(+Vars)</var></a></dt><dd class="defbody">Like <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=all_distinct/1">all_distinct/1</a>, but with weaker propagation. Consider using
<a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=all_distinct/1">all_distinct/1</a> instead, since <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=all_distinct/1">all_distinct/1</a> is typically acceptably
efficient and propagates much more strongly.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#all_distinct/1"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="all_distinct/1"><b class="pred">all_distinct</b><var class="arglist">(+Vars)</var></a></dt><dd class="defbody">True iff <var>Vars</var> are pairwise distinct. For example, <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=all_distinct/1">all_distinct/1</a>
can detect that not all variables can assume distinct values given
the following domains:

<pre class="code" ext="">?- maplist(in, Vs,
           [1\/3..4, 1..2\/4, 1..2\/4, 1..3, 1..3, 1..6]),
   all_distinct(Vs).
false.</pre>

</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#sum/3"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="sum/3"><b class="pred">sum</b><var class="arglist">(+Vars, +Rel, ?Expr)</var></a></dt><dd class="defbody">The sum of elements of the list <var>Vars</var> is in relation <var>Rel</var> to <var>Expr</var>.
<var>Rel</var> is one of #=, #\=, #&lt;, #&gt;, #=&lt; or #&gt;=. For example:

<pre class="code" ext="">?- [A,B,C] ins 0..sup, sum([A,B,C], #=, 100).
A in 0..100,
A+B+C#=100,
B in 0..100,
C in 0..100.</pre>

</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#scalar_product/4"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="scalar_product/4"><b class="pred">scalar_product</b><var class="arglist">(+Cs, +Vs, +Rel, ?Expr)</var></a></dt><dd class="defbody">True iff the scalar product of <var>Cs</var> and <var>Vs</var> is in relation <var>Rel</var> to <var>Expr</var>.
<var>Cs</var> is a list of integers, <var>Vs</var> is a list of variables and integers.
<var>Rel</var> is #=, #\=, #&lt;, #&gt;, #=&lt; or #&gt;=.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src##%3E=/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="#&gt;=/2"><b class="pred">#&gt;=</b><var class="arglist">(?X, ?Y)</var></a></dt><dd class="defbody">Same as <var>Y</var> #=&lt; <var>X</var>. When reasoning over integers, replace <code>(&gt;=)/2</code> by
<a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3E%3D/2">#&gt;=/2</a> to obtain more general relations. See <a href="#clpfd-integer-arith">declarative integer
arithmetic</a>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src##=%3C/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="#=&lt;/2"><b class="pred">#=&lt;</b><var class="arglist">(?X, ?Y)</var></a></dt><dd class="defbody">The arithmetic expression <var>X</var> is less than or equal to <var>Y</var>. When
reasoning over integers, replace <code>(=&lt;)/2</code> by <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3D%3C/2">#=&lt;/2</a> to obtain more
general relations. See <a href="#clpfd-integer-arith">declarative integer
arithmetic</a>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src##=/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="#=/2"><b class="pred">#=</b><var class="arglist">(?X, ?Y)</var></a></dt><dd class="defbody">The arithmetic expression <var>X</var> equals <var>Y</var>. This is the most important
<a href="#clpfd-arith-constraints">arithmetic constraint</a>, subsuming and
replacing both <code>(is)/2</code> <i>and</i> <code>(=:=)/2</code> over integers. See
<a href="#clpfd-integer-arith">declarative integer arithmetic</a>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src##\=/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="#\=/2"><b class="pred">#\=</b><var class="arglist">(?X, ?Y)</var></a></dt><dd class="defbody">The arithmetic expressions <var>X</var> and <var>Y</var> evaluate to distinct integers.
When reasoning over integers, replace <code>(=\=)/2</code> by <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%5C%3D/2">#\=/2</a> to obtain
more general relations. See <a href="#clpfd-integer-arith">declarative integer
arithmetic</a>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src##%3E/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="#&gt;/2"><b class="pred">#&gt;</b><var class="arglist">(?X, ?Y)</var></a></dt><dd class="defbody">Same as <var>Y</var> #&lt; <var>X</var>. When reasoning over integers, replace <code>(&gt;)/2</code> by
<a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3E/2">#&gt;/2</a> to obtain more general relations See <a href="#clpfd-integer-arith">declarative integer
arithmetic</a>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src##%3C/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="#&lt;/2"><b class="pred">#&lt;</b><var class="arglist">(?X, ?Y)</var></a></dt><dd class="defbody">The arithmetic expression <var>X</var> is less than <var>Y</var>. When reasoning over
integers, replace <code>(&lt;)/2</code> by <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=%23%3C/2">#&lt;/2</a> to obtain more general relations. See
<a href="#clpfd-integer-arith">declarative integer arithmetic</a>.

<p>
In addition to its regular use in tasks that require it, this
constraint can also be useful to eliminate uninteresting symmetries
from a problem. For example, all possible matches between pairs
built from four players in total:</p>

<pre class="code" ext="">?- Vs = [A,B,C,D], Vs ins 1..4,
        all_different(Vs),
        A #&lt; B, C #&lt; D, A #&lt; C,
   findall(pair(A,B)-pair(C,D), label(Vs), Ms).
Ms = [ pair(1, 2)-pair(3, 4),
       pair(1, 3)-pair(2, 4),
       pair(1, 4)-pair(2, 3)].</pre>

</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src##\/1"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="#\/1"><b class="pred">#\</b><var class="arglist">(+Q)</var></a></dt><dd class="defbody"><var>Q</var> does <i>not</i> hold. See <a href="#clpfd-reification">reification</a>.

<p>
For example, to obtain the complement of a domain:</p>

<pre class="code" ext="">?- #\ X in -3..0\/10..80.
X in inf.. -4\/1..9\/81..sup.</pre>

</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src##%3C==%3E/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="#&lt;==&gt;/2"><b class="pred">#&lt;==&gt;</b><var class="arglist">(?P, ?Q)</var></a></dt><dd class="defbody"><var>P</var> and <var>Q</var> are equivalent. See <a href="#clpfd-reification">reification</a>.

<p>
For example:</p>

<pre class="code" ext="">?- X #= 4 #&lt;==&gt; B, X #\= 4.
B = 0,
X in inf..3\/5..sup.</pre>

<p>
The following example uses reified constraints to relate a list of
finite domain variables to the number of occurrences of a given value:</p>

<pre class="code" ext="">vs_n_num(Vs, N, Num) :-
        maplist(eq_b(N), Vs, Bs),
        sum(Bs, #=, Num).

eq_b(X, Y, B) :- X #= Y #&lt;==&gt; B.</pre>

<p>
Sample queries and their results:</p>

<pre class="code" ext="">?- Vs = [X,Y,Z], Vs ins 0..1, vs_n_num(Vs, 4, Num).
Vs = [X, Y, Z],
Num = 0,
X in 0..1,
Y in 0..1,
Z in 0..1.

?- vs_n_num([X,Y,Z], 2, 3).
X = 2,
Y = 2,
Z = 2.</pre>

</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src##==%3E/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="#==&gt;/2"><b class="pred">#==&gt;</b><var class="arglist">(?P, ?Q)</var></a></dt><dd class="defbody"><var>P</var> implies <var>Q</var>. See <a href="#clpfd-reification">reification</a>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src##%3C==/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="#&lt;==/2"><b class="pred">#&lt;==</b><var class="arglist">(?P, ?Q)</var></a></dt><dd class="defbody"><var>Q</var> implies <var>P</var>. See <a href="#clpfd-reification">reification</a>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src##/\/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="#/\/2"><b class="pred">#/\</b><var class="arglist">(?P, ?Q)</var></a></dt><dd class="defbody"><var>P</var> and <var>Q</var> hold. See <a href="#clpfd-reification">reification</a>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src##\//2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="#\//2"><b class="pred">#\/</b><var class="arglist">(?P, ?Q)</var></a></dt><dd class="defbody"><var>P</var> or <var>Q</var> holds. See <a href="#clpfd-reification">reification</a>.

<p>
For example, the sum of natural numbers below 1000 that are
multiples of 3 or 5:</p>

<pre class="code" ext="">?- findall(N, (N mod 3 #= 0 #\/ N mod 5 #= 0, N in 0..999,
               indomain(N)),
           Ns),
   sum(Ns, #=, Sum).
Ns = [0, 3, 5, 6, 9, 10, 12, 15, 18|...],
Sum = 233168.</pre>

</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src##\/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="#\/2"><b class="pred">#\</b><var class="arglist">(?P, ?Q)</var></a></dt><dd class="defbody">Either <var>P</var> holds or <var>Q</var> holds, but not both. See
<a href="#clpfd-reification">reification</a>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#lex_chain/1"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="lex_chain/1"><b class="pred">lex_chain</b><var class="arglist">(+Lists)</var></a></dt><dd class="defbody"><var>Lists</var> are lexicographically non-decreasing.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#tuples_in/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="tuples_in/2"><b class="pred">tuples_in</b><var class="arglist">(+Tuples, +Relation)</var></a></dt><dd class="defbody">True iff all <var>Tuples</var> are elements of <var>Relation</var>. Each element of the
list <var>Tuples</var> is a list of integers or finite domain variables.
<var>Relation</var> is a list of lists of integers. Arbitrary finite relations,
such as compatibility tables, can be modeled in this way. For
example, if 1 is compatible with 2 and 5, and 4 is compatible with 0
and 3:

<pre class="code" ext="">?- tuples_in([[X,Y]], [[1,2],[1,5],[4,0],[4,3]]), X = 4.
X = 4,
Y in 0\/3.</pre>

<p>
As another example, consider a train schedule represented as a list
of quadruples, denoting departure and arrival places and times for
each train. In the following program, Ps is a feasible journey of
length 3 from A to D via trains that are part of the given schedule.</p>

<pre class="code" ext="">trains([[1,2,0,1],
        [2,3,4,5],
        [2,3,0,1],
        [3,4,5,6],
        [3,4,2,3],
        [3,4,8,9]]).

threepath(A, D, Ps) :-
        Ps = [[A,B,_T0,T1],[B,C,T2,T3],[C,D,T4,_T5]],
        T2 #&gt; T1,
        T4 #&gt; T3,
        trains(Ts),
        tuples_in(Ps, Ts).</pre>

<p>
In this example, the unique solution is found without labeling:</p>

<pre class="code" ext="">?- threepath(1, 4, Ps).
Ps = [[1, 2, 0, 1], [2, 3, 4, 5], [3, 4, 8, 9]].</pre>

</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#serialized/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="serialized/2"><b class="pred">serialized</b><var class="arglist">(+Starts, +Durations)</var></a></dt><dd class="defbody">Describes a set of non-overlapping tasks.
<var>Starts</var> = [S_1,...,S_n], is a list of variables or integers,
<var>Durations</var> = [D_1,...,D_n] is a list of non-negative integers.
Constrains <var>Starts</var> and <var>Durations</var> to denote a set of
non-overlapping tasks, i.e.: S_i + D_i =&lt; S_j or S_j + D_j =&lt;
S_i for all 1 =&lt; i &lt; j =&lt; n. Example:

<pre class="code" ext="">?- length(Vs, 3),
   Vs ins 0..3,
   serialized(Vs, [1,2,3]),
   label(Vs).
Vs = [0, 1, 3] ;
Vs = [2, 0, 3] ;
false.</pre>

<dl class="tags">
<dt class="keyword-see">See also</dt><dd class="keyword-see">- Dorndorf et al. 2000, "Constraint Propagation Techniques for the
Disjunctive Scheduling Problem"</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#element/3"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="element/3"><b class="pred">element</b><var class="arglist">(?N, +Vs, ?V)</var></a></dt><dd class="defbody">The <var>N</var>-th element of the list of finite domain variables <var>Vs</var> is <var>V</var>.
Analogous to <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=nth1/3">nth1/3</a>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#global_cardinality/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="global_cardinality/2"><b class="pred">global_cardinality</b><var class="arglist">(+Vs, +Pairs)</var></a></dt><dd class="defbody">Global Cardinality constraint. Equivalent to
<code>global_cardinality(Vs, Pairs, [])</code>. See <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=global_cardinality/3">global_cardinality/3</a>.

<p>
Example:</p>

<pre class="code" ext="">?- Vs = [_,_,_], global_cardinality(Vs, [1-2,3-_]), label(Vs).
Vs = [1, 1, 3] ;
Vs = [1, 3, 1] ;
Vs = [3, 1, 1].</pre>

</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#global_cardinality/3"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="global_cardinality/3"><b class="pred">global_cardinality</b><var class="arglist">(+Vs, +Pairs, +Options)</var></a></dt><dd class="defbody">Global Cardinality constraint. <var>Vs</var> is a list of finite domain
variables, <var>Pairs</var> is a list of Key-Num pairs, where Key is an
integer and Num is a finite domain variable. The constraint holds
iff each V in <var>Vs</var> is equal to some key, and for each Key-Num pair
in <var>Pairs</var>, the number of occurrences of Key in <var>Vs</var> is Num. <var>Options</var>
is a list of options. Supported options are:

<dl class="termlist">
<dt class="term"><span class="pl-compound pl-adaptive pl-level-0" data-arity="1" data-name="consistency"><span class="pl-functor pl-trigger">consistency<span class="pl-punct">(</span></span><span class="pl-compound-args"><span class="pl-compound-arg"><span class="pl-atom">value</span></span><span class="pl-compound-close pl-punct">)</span></span></span></dt><dd>A weaker form of consistency is used.</dd>
<dt class="term"><b class="pred">cost</b><var class="arglist">(Cost, Matrix)</var></dt><dd><var>Matrix</var> is a list of rows, one for each variable, in the order
they occur in <var>Vs</var>. Each of these rows is a list of integers, one
for each key, in the order these keys occur in <var>Pairs</var>. When
variable v_i is assigned the value of key k_j, then the
associated cost is <var>Matrix</var>_{ij}. <var>Cost</var> is the sum of all costs.</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#circuit/1"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="circuit/1"><b class="pred">circuit</b><var class="arglist">(+Vs)</var></a></dt><dd class="defbody">True iff the list <var>Vs</var> of finite domain variables induces a
Hamiltonian circuit. The k-th element of <var>Vs</var> denotes the
successor of node k. Node indexing starts with 1. Examples:

<pre class="code" ext="">?- length(Vs, _), circuit(Vs), label(Vs).
Vs = [] ;
Vs = [1] ;
Vs = [2, 1] ;
Vs = [2, 3, 1] ;
Vs = [3, 1, 2] ;
Vs = [2, 3, 4, 1] .</pre>

</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#cumulative/1"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="cumulative/1"><b class="pred">cumulative</b><var class="arglist">(+Tasks)</var></a></dt><dd class="defbody">Equivalent to <code>cumulative(Tasks, [limit(1)])</code>. See <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=cumulative/2">cumulative/2</a>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#cumulative/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="cumulative/2"><b class="pred">cumulative</b><var class="arglist">(+Tasks, +Options)</var></a></dt><dd class="defbody">Schedule with a limited resource. <var>Tasks</var> is a list of tasks, each of
the form <code>task(S_i, D_i, E_i, C_i, T_i)</code>. S_i denotes the start time,
D_i the positive duration, E_i the end time, C_i the non-negative
resource consumption, and T_i the task identifier. Each of these
arguments must be a finite domain variable with bounded domain, or
an integer. The constraint holds iff at each time slot during the
start and end of each task, the total resource consumption of all
tasks running at that time does not exceed the global resource
limit. <var>Options</var> is a list of options. Currently, the only supported
option is:

<dl class="termlist">
<dt class="term"><b class="pred">limit</b><var class="arglist">(L)</var></dt><dd>The integer <var>L</var> is the global resource limit. Default is 1.</dd>
</dl>

<p>
For example, given the following predicate that relates three tasks
of durations 2 and 3 to a list containing their starting times:</p>

<pre class="code" ext="">tasks_starts(Tasks, [S1,S2,S3]) :-
        Tasks = [task(S1,3,_,1,_),
                 task(S2,2,_,1,_),
                 task(S3,2,_,1,_)].</pre>

<p>
We can use <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=cumulative/2">cumulative/2</a> as follows, and obtain a schedule:</p>

<pre class="code" ext="">?- tasks_starts(Tasks, Starts), Starts ins 0..10,
   cumulative(Tasks, [limit(2)]), label(Starts).
Tasks = [task(0, 3, 3, 1, _G36), task(0, 2, 2, 1, _G45), ...],
Starts = [0, 0, 2] .</pre>

</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#disjoint2/1"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="disjoint2/1"><b class="pred">disjoint2</b><var class="arglist">(+Rectangles)</var></a></dt><dd class="defbody">True iff <var>Rectangles</var> are not overlapping. <var>Rectangles</var> is a list of
terms of the form F(X_i, W_i, Y_i, H_i), where F is any functor,
and the arguments are finite domain variables or integers that
denote, respectively, the X coordinate, width, Y coordinate and
height of each rectangle.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#automaton/3"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="automaton/3"><b class="pred">automaton</b><var class="arglist">(+Vs, +Nodes, +Arcs)</var></a></dt><dd class="defbody">Describes a list of finite domain variables with a finite
automaton. Equivalent to <code>automaton(Vs, _, Vs, Nodes, Arcs,
[], [], _)</code>, a common use case of <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=automaton/8">automaton/8</a>. In the following
example, a list of binary finite domain variables is constrained to
contain at least two consecutive ones:

<pre class="code" ext="">two_consecutive_ones(Vs) :-
        automaton(Vs, [source(a),sink(c)],
                  [arc(a,0,a), arc(a,1,b),
                   arc(b,0,a), arc(b,1,c),
                   arc(c,0,c), arc(c,1,c)]).</pre>

<p>
Example query:</p>

<pre class="code" ext="">?- length(Vs, 3), two_consecutive_ones(Vs), label(Vs).
Vs = [0, 1, 1] ;
Vs = [1, 1, 0] ;
Vs = [1, 1, 1].</pre>

</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#automaton/8"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="automaton/8"><b class="pred">automaton</b><var class="arglist">(+Sequence, ?Template, +Signature, +Nodes, +Arcs, +Counters, +Initials, ?Finals)</var></a></dt><dd class="defbody">Describes a list of finite domain variables with a finite
automaton. True iff the finite automaton induced by <var>Nodes</var> and <var>Arcs</var>
(extended with <var>Counters</var>) accepts <var>Signature</var>. <var>Sequence</var> is a list of
terms, all of the same shape. Additional constraints must link
<var>Sequence</var> to <var>Signature</var>, if necessary. <var>Nodes</var> is a list of
<code>source(Node)</code> and <code>sink(Node)</code> terms. <var>Arcs</var> is a list of
<code>arc(Node,Integer,Node)</code> and <code>arc(Node,Integer,Node,Exprs)</code> terms that
denote the automaton's transitions. Each node is represented by an
arbitrary term. Transitions that are not mentioned go to an
implicit failure node. <var>Exprs</var> is a list of arithmetic expressions,
of the same length as <var>Counters</var>. In each expression, variables
occurring in <var>Counters</var> symbolically refer to previous counter
values, and variables occurring in <var>Template</var> refer to the current
element of <var>Sequence</var>. When a transition containing arithmetic
expressions is taken, each counter is updated according to the
result of the corresponding expression. When a transition without
arithmetic expressions is taken, all counters remain unchanged.
<var>Counters</var> is a list of variables. <var>Initials</var> is a list of finite
domain variables or integers denoting, in the same order, the
initial value of each counter. These values are related to <var>Finals</var>
according to the arithmetic expressions of the taken transitions.

<p>
The following example is taken from Beldiceanu, Carlsson, Debruyne
and Petit: "Reformulation of Global Constraints Based on
Constraints Checkers", Constraints 10(4), pp 339-362 (2005). It
relates a sequence of integers and finite domain variables to its
number of inflexions, which are switches between strictly ascending
and strictly descending subsequences:</p>

<pre class="code" ext="">sequence_inflexions(Vs, N) :-
        variables_signature(Vs, Sigs),
        automaton(Sigs, _, Sigs,
                  [source(s),sink(i),sink(j),sink(s)],
                  [arc(s,0,s), arc(s,1,j), arc(s,2,i),
                   arc(i,0,i), arc(i,1,j,[C+1]), arc(i,2,i),
                   arc(j,0,j), arc(j,1,j),
                   arc(j,2,i,[C+1])],
                  [C], [0], [N]).

variables_signature([], []).
variables_signature([V|Vs], Sigs) :-
        variables_signature_(Vs, V, Sigs).

variables_signature_([], _, []).
variables_signature_([V|Vs], Prev, [S|Sigs]) :-
        V #= Prev #&lt;==&gt; S #= 0,
        Prev #&lt; V #&lt;==&gt; S #= 1,
        Prev #&gt; V #&lt;==&gt; S #= 2,
        variables_signature_(Vs, V, Sigs).</pre>

<p>
Example queries:</p>

<pre class="code" ext="">?- sequence_inflexions([1,2,3,3,2,1,3,0], N).
N = 3.

?- length(Ls, 5), Ls ins 0..1,
   sequence_inflexions(Ls, 3), label(Ls).
Ls = [0, 1, 0, 1, 0] ;
Ls = [1, 0, 1, 0, 1].</pre>

</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#transpose/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="transpose/2"><b class="pred">transpose</b><var class="arglist">(+Matrix, ?Transpose)</var></a></dt><dd class="defbody"><var>Transpose</var> a list of lists of the same length. Example:

<pre class="code" ext="">?- transpose([[1,2,3],[4,5,6],[7,8,9]], Ts).
Ts = [[1, 4, 7], [2, 5, 8], [3, 6, 9]].</pre>

<p>
This predicate is useful in many constraint programs. Consider for
instance Sudoku:</p>

<pre class="code" ext="">sudoku(Rows) :-
        length(Rows, 9), maplist(same_length(Rows), Rows),
        append(Rows, Vs), Vs ins 1..9,
        maplist(all_distinct, Rows),
        transpose(Rows, Columns),
        maplist(all_distinct, Columns),
        Rows = [As,Bs,Cs,Ds,Es,Fs,Gs,Hs,Is],
        blocks(As, Bs, Cs), blocks(Ds, Es, Fs), blocks(Gs, Hs, Is).

blocks([], [], []).
blocks([N1,N2,N3|Ns1], [N4,N5,N6|Ns2], [N7,N8,N9|Ns3]) :-
        all_distinct([N1,N2,N3,N4,N5,N6,N7,N8,N9]),
        blocks(Ns1, Ns2, Ns3).

problem(1, [[_,_,_,_,_,_,_,_,_],
            [_,_,_,_,_,3,_,8,5],
            [_,_,1,_,2,_,_,_,_],
            [_,_,_,5,_,7,_,_,_],
            [_,_,4,_,_,_,1,_,_],
            [_,9,_,_,_,_,_,_,_],
            [5,_,_,_,_,_,_,7,3],
            [_,_,2,_,1,_,_,_,_],
            [_,_,_,_,4,_,_,_,9]]).</pre>

<p>
Sample query:</p>

<pre class="code" ext="">?- problem(1, Rows), sudoku(Rows), maplist(portray_clause, Rows).
[9, 8, 7, 6, 5, 4, 3, 2, 1].
[2, 4, 6, 1, 7, 3, 9, 8, 5].
[3, 5, 1, 9, 2, 8, 7, 4, 6].
[1, 2, 8, 5, 3, 7, 6, 9, 4].
[6, 3, 4, 8, 9, 2, 1, 5, 7].
[7, 9, 5, 4, 6, 1, 8, 3, 2].
[5, 1, 9, 2, 8, 6, 4, 7, 3].
[4, 7, 2, 3, 1, 9, 5, 6, 8].
[8, 6, 3, 7, 4, 5, 2, 1, 9].
Rows = [[9, 8, 7, 6, 5, 4, 3, 2|...], ... , [...|...]].</pre>

</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#zcompare/3"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="zcompare/3"><b class="pred">zcompare</b><var class="arglist">(?Order, ?A, ?B)</var></a></dt><dd class="defbody">Analogous to <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=compare/3">compare/3</a>, with finite domain variables <var>A</var> and <var>B</var>.

<p>
Think of <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=zcompare/3">zcompare/3</a> as <i>reifying</i> an arithmetic comparison of two
integers. This means that we can explicitly reason about the
different cases <i>within</i> our programs. As in <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=compare/3">compare/3</a>, the atoms
<code>&lt;</code>, <code>&gt;</code> and <code>=</code> denote the different cases of the
trichotomy. In contrast to <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=compare/3">compare/3</a> though, <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=zcompare/3">zcompare/3</a> works
correctly for <i>all modes</i>, also if only a subset of the arguments is
instantiated. This allows you to make several predicates over
integers deterministic while preserving their generality and
completeness. For example:</p>

<pre class="code" ext="">n_factorial(N, F) :-
        zcompare(C, N, 0),
        n_factorial_(C, N, F).

n_factorial_(=, _, 1).
n_factorial_(&gt;, N, F) :-
        F #= F0*N,
        N1 #= N - 1,
        n_factorial(N1, F0).</pre>

<p>
This version of <span class="undef">n_factorial/2</span> is deterministic if the first argument
is instantiated, because argument indexing can distinguish the
different clauses that reflect the possible and admissible outcomes
of a comparison of <var>N</var> against 0. Example:</p>

<pre class="code" ext="">?- n_factorial(30, F).
F = 265252859812191058636308480000000.</pre>

<p>
Since there is no clause for <code>&lt;</code>, the predicate automatically
<i>fails</i> if <var>N</var> is less than 0. The predicate can still be used in
all directions, including the most general query:</p>

<pre class="code" ext="">?- n_factorial(N, F).
N = 0,
F = 1 ;
N = F, F = 1 ;
N = F, F = 2 .</pre>

<p>
In this case, all clauses are tried on backtracking, and <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=zcompare/3">zcompare/3</a>
ensures that the respective ordering between N and 0 holds in each
case.</p>

<p>
The truth value of a comparison can also be reified with (#&lt;==&gt;)/2
in combination with one of the <a href="#clpfd-arith-constraints"><i>arithmetic
constraints</i></a>. See
<a href="#clpfd-reification">reification</a>. However, <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=zcompare/3">zcompare/3</a> lets you
more conveniently distinguish the cases.</p></dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#chain/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="chain/2"><b class="pred">chain</b><var class="arglist">(+Zs, +Relation)</var></a></dt><dd class="defbody"><var>Zs</var> form a chain with respect to <var>Relation</var>. <var>Zs</var> is a list of finite
domain variables that are a chain with respect to the partial order
<var>Relation</var>, in the order they appear in the list. <var>Relation</var> must be #=,
#=&lt;, #&gt;=, #&lt; or #&gt;. For example:

<pre class="code" ext="">?- chain([X,Y,Z], #&gt;=).
X#&gt;=Y,
Y#&gt;=Z.</pre>

</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fd_var/1"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fd_var/1"><b class="pred">fd_var</b><var class="arglist">(+Var)</var></a></dt><dd class="defbody">True iff <var>Var</var> is a CLP(FD) variable.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fd_inf/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fd_inf/2"><b class="pred">fd_inf</b><var class="arglist">(+Var, -Inf)</var></a></dt><dd class="defbody"><var>Inf</var> is the infimum of the current domain of <var>Var</var>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fd_sup/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fd_sup/2"><b class="pred">fd_sup</b><var class="arglist">(+Var, -Sup)</var></a></dt><dd class="defbody"><var>Sup</var> is the supremum of the current domain of <var>Var</var>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fd_size/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fd_size/2"><b class="pred">fd_size</b><var class="arglist">(+Var, -Size)</var></a></dt><dd class="defbody">Reflect the current size of a domain. <var>Size</var> is the number of
elements of the current domain of <var>Var</var>, or the atom <b>sup</b> if the
domain is unbounded.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fd_dom/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fd_dom/2"><b class="pred">fd_dom</b><var class="arglist">(+Var, -Dom)</var></a></dt><dd class="defbody"><var>Dom</var> is the current domain (see <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=in/2">in/2</a>) of <var>Var</var>. This predicate is
useful if you want to reason about domains. It is <i>not</i> needed if
you only want to display remaining domains; instead, separate your
model from the search part and let the toplevel display this
information via residual goals.

<p>
For example, to implement a custom labeling strategy, you may need
to inspect the current domain of a finite domain variable. With the
following code, you can convert a <i>finite</i> domain to a list of
integers:</p>

<pre class="code" ext="">dom_integers(D, Is) :- phrase(dom_integers_(D), Is).

dom_integers_(I)      --&gt; { integer(I) }, [I].
dom_integers_(L..U)   --&gt; { numlist(L, U, Is) }, Is.
dom_integers_(D1\/D2) --&gt; dom_integers_(D1), dom_integers_(D2).</pre>

<p>
Example:</p>

<pre class="code" ext="">?- X in 1..5, X #\= 4, fd_dom(X, D), dom_integers(D, Is).
D = 1..3\/5,
Is = [1,2,3,5],
X in 1..3\/5.</pre>

</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fd_degree/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fd_degree/2"><b class="pred">fd_degree</b><var class="arglist">(+Var, -Degree)</var></a> is <b class="det">det</b></dt><dd class="defbody"><var>Degree</var> is the number of constraints currently attached to <var>Var</var>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#in_set/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="in_set/2"><var class="arglist">?Var</var> <b class="pred">in_set</b> <var class="arglist">+Set</var></a> is <b class="det">nondet</b></dt><dd class="defbody"><var>Var</var> is an element of the FD set <var>Set</var>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fd_set/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fd_set/2"><b class="pred">fd_set</b><var class="arglist">(?Var, -Set)</var></a> is <b class="det">det</b></dt><dd class="defbody"><var>Set</var> is the FD set representation of the current domain of <var>Var</var>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#is_fdset/1"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="is_fdset/1"><b class="pred">is_fdset</b><var class="arglist">(@Set)</var></a> is <b class="det">semidet</b></dt><dd class="defbody"><var>Set</var> is currently bound to a valid FD set.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#empty_fdset/1"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="empty_fdset/1"><b class="pred">empty_fdset</b><var class="arglist">(-Set)</var></a> is <b class="det">det</b></dt><dd class="defbody"><var>Set</var> is the empty FD set.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fdset_parts/4"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fdset_parts/4"><b class="pred">fdset_parts</b><var class="arglist">(?Set, ?Min, ?Max, ?Rest)</var></a> is <b class="det">semidet</b></dt><dd class="defbody"><var>Set</var> is a non-empty FD set representing the domain <var>Min</var>..<var>Max</var> \/ <var>Rest</var>,
where <var>Min</var>..<var>Max</var> is a non-empty interval (see <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=fdset_interval/3">fdset_interval/3</a>)
and <var>Rest</var> is another FD set (possibly empty).

<p>
If <var>Max</var> is <b>sup</b>, then <var>Rest</var> is the empty FD set. Otherwise, if <var>Rest</var>
is non-empty, all elements of <var>Rest</var> are greater than <var>Max</var>+1.</p>

<p>
This predicate should only be called with either <var>Set</var> or all other
arguments being ground.</p></dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#empty_interval/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="empty_interval/2"><b class="pred">empty_interval</b><var class="arglist">(+Min, +Max)</var></a> is <b class="det">semidet</b></dt><dd class="defbody"><var>Min</var>..<var>Max</var> is an empty interval. <var>Min</var> and <var>Max</var> are integers or one of the
atoms <b>inf</b> or <b>sup</b>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fdset_interval/3"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fdset_interval/3"><b class="pred">fdset_interval</b><var class="arglist">(?Interval, ?Min, ?Max)</var></a> is <b class="det">semidet</b></dt><dd class="defbody"><var>Interval</var> is a non-empty FD set consisting of the single interval
<var>Min</var>..<var>Max</var>.
<var>Min</var> is an integer or the atom <b>inf</b> to denote negative infinity.
<var>Max</var> is an integer or the atom <b>sup</b> to denote positive infinity.

<p>
Either <var>Interval</var> or <var>Min</var> and <var>Max</var> must be ground.</p></dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fdset_singleton/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fdset_singleton/2"><b class="pred">fdset_singleton</b><var class="arglist">(?Set, ?Elt)</var></a> is <b class="det">semidet</b></dt><dd class="defbody"><var>Set</var> is the FD set containing the single integer <var>Elt</var>.

<p>
Either <var>Set</var> or <var>Elt</var> must be ground.</p></dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fdset_min/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fdset_min/2"><b class="pred">fdset_min</b><var class="arglist">(+Set, -Min)</var></a> is <b class="det">semidet</b></dt><dd class="defbody"><var>Min</var> is the lower bound (infimum) of the non-empty FD set <var>Set</var>.
<var>Min</var> is an integer or the atom <b>inf</b> if <var>Set</var> has no lower bound.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fdset_max/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fdset_max/2"><b class="pred">fdset_max</b><var class="arglist">(+Set, -Max)</var></a> is <b class="det">semidet</b></dt><dd class="defbody"><var>Max</var> is the upper bound (supremum) of the non-empty FD set <var>Set</var>.
<var>Max</var> is an integer or the atom <b>sup</b> if <var>Set</var> has no upper bound.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fdset_size/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fdset_size/2"><b class="pred">fdset_size</b><var class="arglist">(+Set, -Size)</var></a> is <b class="det">det</b></dt><dd class="defbody"><var>Size</var> is the number of elements of the FD set <var>Set</var>, or the atom <b>sup</b>
if <var>Set</var> is infinite.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#list_to_fdset/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="list_to_fdset/2"><b class="pred">list_to_fdset</b><var class="arglist">(+List, -Set)</var></a> is <b class="det">det</b></dt><dd class="defbody"><var>Set</var> is an FD set containing all elements of <var>List</var>, which must be a
list of integers.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fdset_to_list/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fdset_to_list/2"><b class="pred">fdset_to_list</b><var class="arglist">(+Set, -List)</var></a> is <b class="det">det</b></dt><dd class="defbody"><var>List</var> is a list containing all elements of the finite FD set <var>Set</var>,
in ascending order.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#range_to_fdset/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="range_to_fdset/2"><b class="pred">range_to_fdset</b><var class="arglist">(+Domain, -Set)</var></a> is <b class="det">det</b></dt><dd class="defbody"><var>Set</var> is an FD set equivalent to the domain <var>Domain</var>. <var>Domain</var> uses the
same syntax as accepted by (in)/2.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fdset_to_range/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fdset_to_range/2"><b class="pred">fdset_to_range</b><var class="arglist">(+Set, -Domain)</var></a> is <b class="det">det</b></dt><dd class="defbody"><var>Domain</var> is a domain equivalent to the FD set <var>Set</var>. <var>Domain</var> is returned
in the same format as by <a class="builtin" href="https://www.swi-prolog.org/pldoc/man?predicate=fd_dom/2">fd_dom/2</a>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fdset_add_element/3"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fdset_add_element/3"><b class="pred">fdset_add_element</b><var class="arglist">(+Set1, +Elt, -Set2)</var></a> is <b class="det">det</b></dt><dd class="defbody"><var>Set2</var> is the same FD set as <var>Set1</var>, but with the integer <var>Elt</var> added.
If <var>Elt</var> is already in <var>Set1</var>, the set is returned unchanged.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fdset_del_element/3"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fdset_del_element/3"><b class="pred">fdset_del_element</b><var class="arglist">(+Set1, +Elt, -Set2)</var></a> is <b class="det">det</b></dt><dd class="defbody"><var>Set2</var> is the same FD set as <var>Set1</var>, but with the integer <var>Elt</var> removed.
If <var>Elt</var> is not in <var>Set1</var>, the set returned unchanged.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fdset_disjoint/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fdset_disjoint/2"><b class="pred">fdset_disjoint</b><var class="arglist">(+Set1, +Set2)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">The FD sets <var>Set1</var> and <var>Set2</var> have no elements in common.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fdset_intersect/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fdset_intersect/2"><b class="pred">fdset_intersect</b><var class="arglist">(+Set1, +Set2)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">The FD sets <var>Set1</var> and <var>Set2</var> have at least one element in common.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fdset_intersection/3"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fdset_intersection/3"><b class="pred">fdset_intersection</b><var class="arglist">(+Set1, +Set2, -Intersection)</var></a> is <b class="det">det</b></dt><dd class="defbody"><var>Intersection</var> is an FD set (possibly empty) of all elements that the
FD sets <var>Set1</var> and <var>Set2</var> have in common.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fdset_member/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fdset_member/2"><b class="pred">fdset_member</b><var class="arglist">(?Elt, +Set)</var></a> is <b class="det">nondet</b></dt><dd class="defbody">The integer <var>Elt</var> is a member of the FD set <var>Set</var>. If <var>Elt</var> is unbound,
<var>Set</var> must be finite and all elements are enumerated on backtracking.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fdset_eq/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fdset_eq/2"><b class="pred">fdset_eq</b><var class="arglist">(+Set1, +Set2)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">True if the FD sets <var>Set1</var> and <var>Set2</var> are equal, i. e. contain exactly
the same elements. This is not necessarily the same as unification or
a term equality check, because some FD sets have multiple possible
term representations.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fdset_subset/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fdset_subset/2"><b class="pred">fdset_subset</b><var class="arglist">(+Set1, +Set2)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">The FD set <var>Set1</var> is a (non-strict) subset of <var>Set2</var>, i. e. every element
of <var>Set1</var> is also in <var>Set2</var>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fdset_subtract/3"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fdset_subtract/3"><b class="pred">fdset_subtract</b><var class="arglist">(+Set1, +Set2, -Difference)</var></a> is <b class="det">det</b></dt><dd class="defbody">The FD set <var>Difference</var> is <var>Set1</var> with all elements of <var>Set2</var> removed,
i. e. the set difference of <var>Set1</var> and <var>Set2</var>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fdset_union/3"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fdset_union/3"><b class="pred">fdset_union</b><var class="arglist">(+Set1, +Set2, -Union)</var></a> is <b class="det">det</b></dt><dd class="defbody">The FD set <var>Union</var> is the union of FD sets <var>Set1</var> and <var>Set2</var>.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fdset_union/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fdset_union/2"><b class="pred">fdset_union</b><var class="arglist">(+Sets, -Union)</var></a> is <b class="det">det</b></dt><dd class="defbody">The FD set <var>Union</var> is the n-ary union of all FD sets in the list <var>Sets</var>.
If <var>Sets</var> is empty, <var>Union</var> is the empty FD set.</dd>
<dt class="pubdef"><span style="float:right"><a href="https://www.swi-prolog.org/pldoc/doc/_SWI_/library/clp/clpfd.pl?show=src#fdset_complement/2"><img class="action" alt="Source" title="Show source" src="clpfd_files/source.png"></a>&nbsp;</span><a name="fdset_complement/2"><b class="pred">fdset_complement</b><var class="arglist">(+Set, -Complement)</var></a> is <b class="det">det</b></dt><dd class="defbody">The FD set <var>Complement</var> is the complement of the FD set <var>Set</var>.
Equivalent to fdset_subtract(inf..sup, <var>Set</var>, <var>Complement</var>).</dd>
</dl>

</div>
</div>
<div id="dialog" style="display:none;"></div>
<div class="footer newstyle">
<div class="footer">
<div id="footer">
<div class="current-user"><a class="signin" href="https://www.swi-prolog.org/openid/login?openid.return_to=/pldoc/doc/_SWI_/library/clp/clpfd.pl">login</a></div>
<a id="powered" href="http://www.swi-prolog.org/">Powered by SWI-Prolog 9.1.10</a></div>
</div>
<script type="text/javascript">

		   $().ready(function()
	           { var $navtree = $(".navwindow");
		     var $navcontent = $(".navcontent");
		     if ( $navtree.length > 0 && $navcontent.length > 0 )
		     { var $window = $(window).on("resize", function()
		       { var ch = $navcontent.height();
			 var nh = $navtree.height();
			 if ( nh > 400 && nh > ch + 200 )
			 { if ( ch < 300 ) ch = 300;
			   $navtree.height(ch);
			   $navtree.css('overflow-y', 'scroll');

			   var current = $navtree.find("li.nav.current");
			   if ( current.position().top > ch-40 )
			   { $navtree.scrollTop(current.position().top - (ch-40));
			   }
			 }
		       }).trigger("resize")
		     }
		   });
		  
</script>
</div>
<div id="tail-end">&nbsp;</div>
</div>



<ul id="ui-id-1" tabindex="0" class="ui-menu ui-widget ui-widget-content ui-autocomplete ui-front" style="display: none;" unselectable="on"></ul><div role="status" aria-live="assertive" aria-relevant="additions" class="ui-helper-hidden-accessible"></div></body></html>